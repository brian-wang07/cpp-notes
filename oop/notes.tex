% !TeX option = --shell-escape
\documentclass[12pt,a4paper]{article}

% ---------- BASIC PACKAGES ----------
\usepackage[utf8]{inputenc}
\usepackage{changepage}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage{setspace}
\usepackage{parskip} % removes indentations
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{tcolorbox}
\usepackage{fancyhdr}

% ---------- CODE HIGHLIGHTING (minted) ----------
\usepackage{minted}

% Global minted settings for notes
\setminted{
  fontsize=\small,
  breaklines=true,
  autogobble
  %frame=single,
  %framesep=2mm
}

% Convenience environment for C++ code blocks
\newminted{cpp}{
  linenos,
  breaklines,
  fontsize=\small
}

% Inline C++: \cppinline{int x = 0;}
\newmintinline{cpp}{}

% ---------- HYPERREF (load after most packages) ----------
\usepackage{hyperref}

% ---------- PAGE STYLE ----------
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textit{Chapter 1}}
\fancyhead[R]{\thepage}

% ---------- TITLE STYLE ----------
\titleformat{\section}{\Large\bfseries}{\thesection.}{0.5em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection.}{0.5em}{}

% ---------- CUSTOM COLORS ----------
\definecolor{lightgray}{gray}{0.9}
\definecolor{highlight}{HTML}{FFF2CC}
\definecolor{myblue}{HTML}{005B96}

% ---------- CUSTOM COMMANDS ----------
% Highlight text
\newcommand{\hl}[1]{\colorbox{highlight}{#1}}

% Important term / keyword
\newcommand{\term}[1]{\textbf{\textcolor{myblue}{#1}}}

% Quotation box
\newtcolorbox{quoteBox}{
  colback=lightgray,
  colframe=white,
  boxrule=0pt,
  sharp corners,
  left=1em, right=1em, top=0.5em, bottom=0.5em
}

% Example or note box
\newtcolorbox{noteBox}[1][]{
  colback=highlight!40,
  colframe=myblue!40!black,
  title=#1,
  fonttitle=\bfseries,
  sharp corners,
  top=1em, bottom=1em
}

%Indentation
\newenvironment{indentblock}[1][2em]
  {\begin{adjustwidth}{#1}{0pt}}
  {\end{adjustwidth}}

% ---------- DOCUMENT ----------
\begin{document}

\begin{center}
  {\Huge \textbf{Intro to OOP}} \\
  \vspace{1em}
  C++\\  
\end{center}
\vspace{1em}
\hrule
\vspace{1em}

\section{Classes (I)}
\subsection{Introduction}
\begin{verbatim}
    use \begin{cppcode} and \cppinline
\end{verbatim}
\term{Class}: A class is a type of datastructure that can hold data members and member functions.\\ 
\term{Object}: An instantiation of a class.\\
Classes are defined using the keyword \cppinline{class} or \cppinline{struct}. A typical class implementation may look like the following:
\begin{cppcode}
    class ClassName {
    accessSpecifier1:
      member1;
    accessSpecifier2:
      member2;
        ...
    } objectNames;
\end{cppcode}
Access specifiers define access rights to the data stored within a class. They can be one of \cppinline{private}, \cppinline{public}, or \cppinline{protected}. By default, members are set to \cppinline{private}.
\begin{enumerate}
    \item \cppinline{private} members can only be accessed from within the class itself.
    \item \cppinline{public} members can be accessed anywhere.
    \item \cppinline{protected} members can be accessed from within the class and through derived classes.
\end{enumerate}
\begin{cppcode}
    class Rectangle {
      int width, length;
    public:
      void set_values(int, int);
      int area(void);
   } rect; 
\end{cppcode}
In the code above, we create a Rectangle class and instantiate an object rect. We define a private width and length, and public methods \cppinline{set_values} and \cppinline{area}. We are able to access the public members simply as normal function calls:
\begin{cppcode}
    rect.set_values(5, 4);
    rect.area();
\end{cppcode}
Note that the code above does not implement any behaviour to \cppinline{set_values} nor \cppinline{area}. We can either implement behaviour within the class as a normal function, or use the scope operator and define it outside, as follows:
\vspace{4em}
\begin{cppcode}
#include <iostream>

//create Rectangle Class
class Rectangle {
  int width, length;
public:
  void set_values(int, int);
  int area(void) {
    return width*length;
    }
};

//We can implement behaviour of prototype functions within a class by using the :: operator.
void Rectangle::set_values(int x, int y){
  width = x;
  length = y;
}

int main(){
  Rectangle rect;
  rect.set_values(3, 4);
  std::cout << rect.area() << std::endl;
  return 0;
}
\end{cppcode}
The code above will print the value \cppinline{12}. Note that each instantiation of a class is independent to each other. For example,
\begin{cppcode}
...
int main(){
  Rect rectA, rectB;
  recta.set_values(3, 4);
  rectb.set_values(5, 6);
  std::cout << "rectA area: " << rectA.area() << std::endl;
  std::cout << "rectB area: " << rectB.area() << std::endl;
  return 0;
}
\end{cppcode}
Output:
\begin{verbatim}
rectA area: 12
rectB area: 30
\end{verbatim}
\vspace{-1em}

\subsection{Constructors}
In the code shown above, what would happen if we were to call \cppinline{area()} before \cppinline{set_values}? An undetermined result, since we havent initialized width or height.
In order to avoid this behaviour, we can introduce a special member, known as a constructor.\\
\term{Constructor}: A constructor is a method that is called automatically when a new object is instantiated.\\
A constructor is defined by a method that has the exact same name as the class, and no return type; not even \cppinline{void}.
For example:
\begin{cppcode}
#include <iostream>

class Rectangle {
  int width, height;
public:
  Rectangle(int, int); //prototype constructor - takes the same name as the class, with no return type
  int area(void) {
    return width * height;
  }
};

//constructor definition
Rectangle::Rectangle(int x, int y){
  width = x;
  height = y;
}

int main(){
  //instantiate rect with (3, 4) parameters
  Rectangle rect(3, 4);
  std::cout << rect.area() << std::endl;
  return 0;
}
\end{cppcode}
Output:
\begin{verbatim}
12
\end{verbatim}
\vspace{-1em}
\subsubsection{Overloading Constructors}
Constructors also have the ability to be overloaded. This can be useful 
in cases where you want different instantiation behaviour. For example:

\begin{cppcode}
#include <iostream>

class Rectangle {
  int width, height;
public:
  //Rectangle constructor with 2 parameters
  Rectangle(int x, int y){
    width = x;
    height = y;
  }

  //Rectangle constructor with 1 parameter
  Rectangle(int x){
    width = x;
    height = x;
  }

  //overload default constructor
  Rectangle(){
    width = 10;
    height = 10;
  }

  int area(void){
    return width * height;
  }
};

int main() {
  Rectangle rect(3, 4);
  Rectangle square(5);
  Rectangle default_rect;
  return 0;
}
\end{cppcode}
In this case, since \cppinline{square} only has one parameter, it will assume the Rectangle constructor that only accepts one parameter.
As well, we have overloaded the default constructor, which is called when we pass no parameters.
Note that \cppinline{default_rect()} would NOT work. In this case, it would create a \cppinline{default_rect()} function declaration,
instead of calling the default constructor. 
\subsubsection{Uniform initialization}
The method of calling constructors as shown above, by enclosing the arguments in parenthesis is known as functional form.
However, C++ allows for other syntaxes. 

First, if a constructor only takes a single parameter, it can be called implicitly with variable assignment:
\begin{cppcode}
ClassName objectName = initializationValue;
\end{cppcode}
The code above is equivalent to
\begin{cppcode}
ClassName objectName = initializationValue;
\end{cppcode}
Added in C++11, uniform initialization is essentially the same as functional form, but instead uses braces.
\begin{cppcode}
ClassName objectName { value1, value2, ... }
\end{cppcode}
The benefit of uniform initialization is that it strictly enforces types, which protects you from accidently losing precision.
\begin{cppcode}
int x{3.14}; //ERROR: Narrowing conversion
int y(3.14); //Allowed, however y becomes 3.
\end{cppcode}
For example:
\begin{cppcode}
#include <iostream>
const double PI = 3.14159265

class Circle {
  double radius;
public:
  Circle(double r) {
    radius = r;
  }

  double circum() {
    return 2 * radius * PI
  }
};

int main() {
  Circle foo(10.0); //Functional initialization
  Circle bar = 20.0; //Assignment initialization
  Circle baz {40.0}; //uniform initialization
  return 0;
}
\end{cppcode}
Whilst this choice of constructors is largely just a mater of style, many newer style guides suggest to use uniform initialization.
\subsubsection{Member Initialization in Constructors}
Many times in a constructor, we need only to initialize other members. This can be done by using a colon and a list of initializations.
For example,
\begin{cppcode}
class Rectangle {
  int width, length;
public:
  Rectangle(int, int);
  int area() {
    return width*length;
  }
}
\end{cppcode}
Here, the constructor can be defined as shown before as 
\begin{cppcode}
  Rectangle::Rectangle(int x, int y) {width = x; length = y;}
\end{cppcode}
Or, using member initialization:
\begin{cppcode}
  Rectangle::Rectangle(int x, int y) : width(x), length(y) {}
\end{cppcode}
Notice that we have an empty constructor body as well. This is because we want the constructor to only 
initialize the members, and have no added functionality. 

While default constructing may just seem like a convenient shorthand, it does have some applications where it is necessary. Consider the following:
\begin{cppcode}
#include <iostream>
const double PI = 3.14159265

class Circle {
  double radius;
public:
  Circle(double r) : radius(r) {}
  double area() {
    return radius * radius * PI;
  }
};

class Cylinder {
  Circle base;
  double height;
public:
  Cylinder(double r, double h) : base(r), height(h) {}
  double volume() {
    return base.area() * height;
  }
};

int main() {
  Cylinder foo(10, 20);

  cout << "Volume: " << foo.volume() << std::endl;
  return 0;
}
\end{cppcode}

In this example, the class \cppinline{Cylinder} has a member of type \cppinline{Circle}. Because objects of class 
\cppinline{Circle} can only be initialized with a parameter, \cppinline{Cylinder} needs to invoke \cppinline{Circle}'s constructor.
This is only possible through a member initialization list.\\
Note that initialization lists can also be created using uniform initialization.
\begin{cppcode}
Cylinder::Cylinder(double r, double h) : base{r}, height{h} {} //with {} syntax
\end{cppcode}
\subsection{Pointers to Classes}
Since classes are just an object type, we can define a pointer that points at a class type. For example,
\begin{cppcode}
  Rectangle *pRect;
\end{cppcode}
Creates a pointer to an object of class \cppinline{Rectangle}.\\
Much like with built in datastructures, we can access members of an object directly from a pointer by using the arrow operator.
\begin{cppcode}
#include <iostream>

class Rectangle {
  int width, length;
public:
  Rectangle(int x, int y) : width(x), length(y) {}
  int area(void) {
    return width * height;
  }
};

int main() {
  Rectangle obj(3, 4); //object instantiation
  Rectangle *foo, *bar, *baz;
  foo = &obj;
  bar = new Rectangle(5, 6);
  baz = new Rectangle[2]{{2, 5}, {3, 6}};

  cout << "obj area: " << obj.area() << std::endl;
  cout << "*foo area: " << foo->area() << std::endl;
  cout << "*bar area: " << (*bar).area() << std::endl;
  cout << "baz[0] area: " << baz[0].area() << std::endl;
  cout << "baz[1] area: " << *(baz + 1).area() << std::endl;
  
  delete bar;
  delete[] baz;
  return 0;
}
\end{cppcode}

\subsection{Classes Defined with Struct and Union}
Classes also be defined using the keyword \cppinline{struct} and \cppinline{union}.

The keyword \cppinline{struct} can also be used to declare classes that have member functions, which have
the exact same syntax as \cppinline{class}, however members have \cppinline{public} access by default. 

The concept of unoins, however, is quite different to that of \cppinline{class} and \cppinline{struct}. Unions can only have
a single data member active at a time, but they can also hold multiple member functions. That is, members in a union will share a common memory address, with 
the size allocated being the largest member. The default access for union is \cppinline{public}.

\section{Classes (II)}
\subsection{Overloading Operators}
In C++, different types have different interactions with operators. For example,
\begin{cppcode}
#include <string>

int a, b, c;
a = b + c; //arithmetic addition

std::string str1, str2, str3;
str1 = str2 + str3; //string concatenation
\end{cppcode}
Therefore we sometimes have the need to define interactions with operators, as the 
operation to be performed can be ambiguous. Consider:

\begin{cppcode}
#include <string>

class MyClass {
  std::string str;
  float number;
} a, b, c;

a = b + c;
\end{cppcode}
Here, it is not obvious what the \cppinline{+} operator should do. In fact, this would cause a compilation error,
as we have not explicity defined behavaiour for \cppinline{+}.
The good news is that C++ allows for most operators to be overloaded so that their behvaiour can be defined for almost any type, including classes.
We overload opeartors by using \cppinline{operator} functions, which take on the form
\begin{cppcode}
type operator sign (parameters) {body}
\end{cppcode}
For example, consider cartesian vector addition. We have two vectors (a, b) and (x, y), and their sum is defined as
(a+x, b+y).

\begin{cppcode}
#include <iostream>
class CVector {
public:
  int x, y;
  CVector (int a, int b) : x(a), y(b) {}
  CVector operator+ (const CVector&); //+ operator prototype 
  //Note that we have to pass a const lvalue reference of CVector, to allow rvalue references. In other words, this setup ensures that an expression such as a = b + CVector(1, 2) is valid.
};

CVector CVector::operator+ (const CVector& b) {
  CVector result;
  result.x = x + b.x;
  result.y = y + b.y;
  return result;
}

int main() {
  CVector foo(3, 1);
  CVector bar(5, 2);

  CVector result;
  result = foo + bar;

  cout << result.x << ','<< result.y << std::endl;
  return 0;
}
\end{cppcode}
Output:
\begin{verbatim}
8,3
\end{verbatim}
Note that we can also call the operator explicitly:
\begin{cppcode}
result = foo.operator+ (bar); //8,3
\end{cppcode}
We can also overload operators as non-member functions, as below:
\begin{cppcode}
#include <iostream>
class CVector {
public:
  int x, y;
  CVector (int a, int b) : x(a), y(b) {}
  CVector operator+ (const CVector&); //+ operator prototype 
};

CVector operator+ (const CVector& lhs, const CVector& rhs) {
  CVector result;
  result.x = lhs.x + rhs.x;
  result.y = lhs.y + rhs.y;
  return result;
}

int main() {
  CVector foo(3, 1);
  CVector bar(5, 2);

  CVector result;
  result = foo + bar;

  cout << result.x << ','<< result.y << std::endl;
  return 0;
}
\end{cppcode}
Output:
\begin{verbatim}
8,3
\end{verbatim}
Notice that when in this case, we must pass an instance of the class as a first argument.
\subsection{"This"}
The keyword \cppinline{this} is a pointer to the the object itself. It is analogous to the keyword \cppinline{self} in Python,
however it is implicit in C++.

One of it's uses can be to check if a parameter passed to a member function is the object itself. For example:
\begin{cppcode}
#include <iostream>

class Dummy {
public:
  bool isitme(Dummy& param);
};

bool Dumy::isitme(Dummy& param) {
  if (&param == this)
    return true;
  return false;
}

int main() {
  Dummy a;
  Dummy* b = &a;

  if (b->isitme(a))
    cout << "&a is b" << std::endl;
  return 0;
}
\end{cppcode}
Output:
\begin{verbatim}
&a is b
\end{verbatim}
\subsection{Static Members}
A class can contain static data or functions. A static data member is known as a class variable. Static data members are
constant amongst all object instantiations of the class.
\begin{cppcode}
#include <iostream>

class Dummy {
public:
  static int n;
  Dummy() {n++;} //increment n each time we create an instantiation of Dummy.
};

int Dummy::n = 0;

int main() {
  Dummy a;
  Dummy b[5];
  std::cout << a.n << std::endl;
  Dummy *c = new Dummy;
  std::cout << Dummy::n << std::endl;
  delete c;
  return 0;
}
\end{cppcode}
Output:
\begin{verbatim}
6
7
\end{verbatim}
In general, it is good practice to initialize static members outside of the class definition, using the scope operator.
This is to avoid reassignment of the static member whenever a new object is created.
Because it is a common variable amongst all objects, it can be reffered to as a member of any object of that class or directly 
by the class name, by scoping.

\subsection{Const Member Functions}
When an object of a class is defined using \cppinline{const}, it restricts the object as if all members were read only.
THIS ALSO INCLUDES CONST REFERENCES!!!!
\begin{cppcode}
#include <iostream>

class MyClass {
public:
  int x;
  MyClass(int val) : x(val) {}
  int get() {
    return x;
  }
};

int main() {
  const MyClass foo(10);
  //foo.x = 15;  //Compile Error: Cannot modify read only
  std::cout << foo.x << std::endl;
  return 0;
}
\end{cppcode}
Output:
\begin{verbatim}
10
\end{verbatim}
We are unable to modify \cppinline{foo.x}, as \cppinline{foo} was declared as \cppinline{const}. However, notice that we are able to 
initialize \cppinline{x = 10}.Member functions of a \cppinline{const} object can only be called if they are also specified as \cppinline{const}.
To specify this, we add the \cppinline{const} keyword after the parameters:
\begin{cppcode}
int get() const {return x;}
\end{cppcode}
Note that \cppinline{const} in this context is different to returning a \cppinline{const} type; here, only \cppinline{const} members can be called
for \cppinline{const} objects.
\begin{cppcode}
int get() const {return x;} //const member function
const int& get() {return x;} //nonconst member function returning a const&
const int& get() const {return x;} //const member function returning a const&
\end{cppcode}
We are also able to overload "constness":
\begin{cppcode}
#include <iostream>

class MyClass {
  int x;
public:
  MyClass(int val) : x(val) {}
  //const
  const int& get() const {return x;}

  //nonconst
  int& get() {return x;}
};

int main() {
  MyClass foo(10);
  const MyClass bar(20);

  foo.get() = 15; //dispatched to nonconst
  //bar.get() = 20; //NOT allowed: return type of bar.get() is const int&, which cannnot be modified.

  std::cout << foo.get() << std::endl;
  std:: cout << bar.get() << std::endl;

  return 0;
}
\end{cppcode}
Output:
\begin{verbatim}
15
20
\end{verbatim}
\subsection{Class Templates}
Class templates allow us to store data of any type. Consider:
\begin{cppcode}
template <class T>
class MyPair {
  T values[2];
public:
  MyPair(const T (&arr)[2]) : value{arr[0], arr[1]} {}
  }
};
\end{cppcode}
This code will store two elements of any time, so long as they are both the same. For example, the following examples are all valid:
\begin{cppcode}
MyPair<int> myInt(115, 36);
MyPair<double> myFloats(3.0, 2.18);
MyPair<std::string> myStrings("hello", "world");
\end{cppcode}
In order to define member functions outside of the class definition, ensure that it is preceded with the \cppinline{template <...>} prefix:

\begin{cppcode}
#include <iostream>

template <class T>
class MyPair{
  T values[2];
public:
  MyPair(T first, T second) {
    a = first; b = second;
  }

  T getmax();
};

template <class T>
T mypair<T>::getmax() {
  T returnValue;
  returnValue = a > b ? a : b;
  return returnValue;
}

int main() {
  MyPair<int> myObject(100,75);
  std::cout << myObject.getmax() << std::endl;
  return 0;
}
\end{cppcode}
Output:
\begin{verbatim}
100
\end{verbatim}
\subsection{Template Specialization}
We can define different behaviour for a template depending on the type that is passed. For example, suppose we have a class \cppinline{MyContainer} that has a \cppinline{increase} member function,
which just increments its value. However, if we were to pass a \cppinline{char}, we would want different implementation, say, \cppinline{uppercase}.
\begin{cppcode}
#include <iostream>

//class template:
template <class T>
class MyContainer {
  T element;
public:
  MyContainer(T param) : element(param) {}
  T increase () {
    return ++element;
  }
};

//class template specialization:
template <>
class MyContainer <char> {
  char element;
public:
  MyContainer (char param) : element(param) {}
  char uppercase (){
    if ((element>='a') && (element<='z'))
      element += 'A'-'a';
    return element;
  }
};

int main() {
  MyContainer<int> myInt(7);
  MyContainer<char> myChar('j');
  std::cout << myInt.increase() << std::endl;
  std::cout << myChar.uppercase() << std::endl;
  return 0;
}
\end{cppcode}
Output:
\begin{verbatim}
8
J
\end{verbatim}
The syntax used for class template specialization:
\begin{cppcode}
template <> class myContainer <char> {...};
\end{cppcode}
\section{Special Members}
Special member functions are member functions that are, by default, implicitly defined as member functions (under specific circumstances). There are six:
\begin{enumerate}
  \item \term{Default constructor}: \cppinline{C::C();}
  \item \term{Destructor}: \cppinline{C::~C();}
  \item \term{Copy constructor}: \cppinline{C::C(const C&);}
  \item \term{Coppy assignment}: \cppinline{C& operator=(const C&);}
  \item \term{Move constructor}: \cppinline{C::C(C&&);}
  \item \term{Move assignment}: \cppinline{C& operator=(C&&);}
\end{enumerate}
\subsection{Default Constructor}
If a class is not explicity defined with a constructor, the compiler assumes a default constructor. Therefore, the following class:
\begin{cppcode}
class Example{
public:
  int total;
  void accumulate(int x) {
    total += x;
  }
};
\end{cppcode}
is assumed to have a default constructor. Therefore, we can initialize an object by declaring them with no parameters:
\begin{cppcode}
Example myObject;
\end{cppcode}
However, once we explicitly define a constructor, the compiler will no longer provide the defualt constructor therefore:
\begin{cppcode}
class Example2 {
public:
  int total;
  Example2 (int initial) : total(initial) {}
  void accumulate(int x) {
    total += x;
  }
}
\end{cppcode}
We must provide an argument when we instantiate the class.
\begin{cppcode}
Example2 myObj(100); //Okay: implicitly calls constructor
Example2 myObj = Example2(100) //Okay: explicitly call constructor
Example2 ex; //Not valid: no default constructor provided.
\end{cppcode}

\subsection{Destructor}
Destructors do the opposite of constructors: they are called when an object is destroyed, or when it goes out of scope.
Up untill now, we have not had to allocate any memory when creating objects, therefore the need for a destructor was not necessary.
However, imagine that the class dynamically allocates memory to store a string. In this case, it would be quite useful to have a function that is automatically called
whenever the object goes out of scope, so that we can release it's memory. We can create this by using a destructor. They are created in a similar fashion to constructors,
where they have no return value, but they take no arguments and the class name is preceded with a tilde (~).
\begin{cppcode}
#include <string>
#include <iostream>

class Example3 {
  std::string *ptr;
public:
  Example3(): ptr(new std::string) {} //default constructor
  Example (const std::string& str) : ptr(new std::string(str)) {}

  //destructor:
  ~Example3() {delete ptr;}
  
  //access content(Read only)
  const std::string& content() const {return *ptr;}
};

int main() {
  {Example3 foo;}
  Example3 bar ("Example");
  std::cout << "bar: " << bar.content() << std::endl;
  return 0;
}
\end{cppcode}
Output:
\begin{verbatim}
bar: Example
\end{verbatim}
\subsection{Copy Constructor}
When an object is passed a \textbf{named} object of its own type as an argument, its copy constructor is invoked to copy the object.
A copy constructor is a constructor who's first parameter is a const reference to the class itself (Why? A copy should never change the original). Thus a copy constructor must have the following signature:
\begin{cppcode}
MyClass::MyClass(const MyClass&)
\end{cppcode}
If a class has no custom copy nor move constructors defined, an implicit copy constructor is provided. This copy performs a \textit{shallow copy}. For example,
\begin{cppcode}
class MyClass {
public:
  int a, b;
  string c;
}
\end{cppcode}
The implicit copy constructor would look something like:
\begin{cppcode}
MyClass::MyClass(const MyClass& x): a(x.a), b(x.b), c(x.c) {}
\end{cppcode}
In most use cases, the default copy constructor is sufficient. However, shallow copies only copy the member of the class. 
Consider \cppinline{Example3}. When we copy \cppinline{Example3}, this would create a copy of only the pointer value, and not the content; 
thus, both pointers would point to the same value, and would share a single \cppinline{string} object. At some point for destruction,
both objects would attempt to delete the same value, and would (in most cases) cause a classic \texttt{segfault}. This can be solved
by creating a custom copy constructor that performs a deep copy:
\begin{cppcode}
#include <iostream>
#include <string>

class Example4 {
  std::string *ptr;
public:
  //constructor
  Example4(const std::string& str) : ptr(new std::string(str)) {}
  //destructor
  ~Example4() {delete ptr;}
  //copy constructor:
  Example4(const Example4& other) : ptr(new std::string(other.content())) {}
  //access content: 
  //NEEDS TO BE CONST METHOD!!!! a const method (the copy constructor) is invoking this method, thus it also needs to be const.
  const std::string& content() const {
    return *ptr;
  }
};

int main() {
  Example4 foo("Example");
  Example4 bar = foo;

  std::cout << "bar: " << bar.content() << std::endl;
  return 0;
}
\end{cppcode}
Output:
\begin{verbatim}
bar: Example
\end{verbatim}
\subsection{Copy Assignment}
Seen above, we are calling the copy contructor when declaring a new variable /cppinline{bar}. However, copying can also be done through assignment.
\begin{cppcode}
MyClass foo;
MyClass bar(foo); //object declaration: copy constructor invoked
MyClass baz = foo; //object declaration: copy constructor invoked
foo = bar; //object assignment: copy assignment invoked
\end{cppcode}
The copy assignment operator is an overload of \cppinline{operator=} which takes a reference of the class as a parameter.
The value is generally a reference to \cppinline{this*}. For example, for \cppinline{MyClass}, a copy assignment could have a signiture that looks like:
\begin{cppcode}
MyClass& operator=(Const MyClass&); 
\end{cppcode}
Implicitly, the copy assignment is defined as a shallow copy, much like the copy constructor. However, we can implement a deep copy in a similar fashion:
\begin{cppcode}
//inside Example4
Example4& operator=(const Example4& other) {
  *ptr = x.content() //ptr is not const
  return *this; 
}
\end{cppcode}
\subsection{Move Constructor and Assignment}
Move semantics can be one of the most confusing parts of learning C++. After all, the definition of cppreference for many can cause even more confusion:
\begin{quoteBox}
\cppinline{std::move} produces an xvalue expression that identifies its arguement \cppinline{t}. It is exactly equivalent to a \cppinline{static_cast} to an rvalue reference type.\\
Returns \cppinline{static_cast<typename std::remove_reference<T>::type&&>(t)}
\end{quoteBox}
Doesn't really tell us that much. Simply put, moving an object involves "transferring" ownership of content from one object to another. The source loses it's content, which is taken over by the destination.
This move can only occur iff the source is an unnamed object.\\ 
\term{Unnamed object}: Unnamed objects are objects that are temporary in nature, and thus don't have a name. Often times these are rvalues: values which don't have a spot in memory. Other examples 
may include return values of function or type-casts.\\
Using the value of a temporary object to initialize another object/assign it value does not require a copy; after all, there is no address to copy from. Instead, we move the value of the source into the destination.
This invokes a different kind of method: move constructors and move assignments.
\begin{cppcode}
MyClass fn(); //function returning a MyClass object
MyClass foo; //default constructor
MyClass bar = foo; //copy constructor
MyClass baz = fn(); //move constructor
foo = bar; //copy assignment
baz = MyClass; //move assignment; equal to baz = MyClass temp{};
\end{cppcode}
The move constructor and assignment are members that take an rvalue reference of the class. Syntactically, this is done with a double ampersand.
\begin{cppcode}
MyClass (MyClass&&); //move constructor: takes a rvalue reference
MyClass& operator=(MyClass&&); move assignment
\end{cppcode}
In classes that must dynamically allocate memory, move constructors and assignments are extremely important. We don't want to create a copy of the class if we are just passing
a temporary instance of the class.
\begin{cppcode}
#include <iostream>
#include <string>

class Example5 {
  std::string *ptr;
public:
  Example5 (const std::string& ptr) : ptr(new std::string(str)) {}
  ~Example5 () {delete ptr;}

  //move constructor
  Example5 (Example5&& other) {
    this->ptr = other.ptr; //copies the pointer to this
    other.ptr = nullptr; //deassigns other pointer
  } 

  //move assignment
  Example5& operator=(Example5&& other) {
    ptr = other.ptr;
    x.ptr = nullptr;
    return *this;
  }

  //access content
  const std::string& content() const {return *ptr;}
  //addition
  Example5 operator+(const Example5& rhs) {
    return Example5(content() + rhs.content());
  }
};

int main() {
  Example5 foo("Exam");
  Example5 bar = Example5("ple"); //move constructor
  foo = foo + bar; //move assignment
  std::cout << "foo: " << foo.content() << std::endl;
}
\end{cppcode}
Output:
\begin{verbatim}
foo: Example
\end{verbatim}
We can also invoke the move constructor using a pre-existing object, and transfer ownership using \cppinline{std::move}.
\begin{cppcode}
Example5 foo("Example");
Example5 bar = std::move(foo) //move constructor invoked: foo is valid but unspecified, and bar contains "Example"
\end{cppcode}
Maybe now the definition of \cppinline{std::move} makes more sense. All it does is it simply takes an object and casts it to an rvalue, and nothing else.
Since we are then defining \cppinline{bar} with an rvalue, it invokes the move constructor.
\end{document}



